<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Platter</name>
    </assembly>
    <members>
        <member name="F:Platter.Mod.ModName">
            <summary>
            The mod's default name.
            </summary>
        </member>
        <member name="F:Platter.Mod.Id">
            <summary>
            An id used for bindings between UI and C#.
            </summary>
        </member>
        <member name="P:Platter.Mod.Instance">
            <summary>
            Gets the active instance reference.
            </summary>
        </member>
        <member name="P:Platter.Mod.ActiveSettings">
            <summary>
            Gets the mod's active settings configuration.
            </summary>
        </member>
        <member name="P:Platter.Mod.Log">
            <summary>
            Gets the mod's active log.
            </summary>
        </member>
        <member name="T:Platter.ModSettings">
            <summary>
            The mod's settings.
            </summary>
        </member>
        <member name="M:Platter.ModSettings.#ctor(Game.Modding.IMod)">
            <summary>
            Initializes a new instance of the <see cref="T:Platter.ModSettings"/> class.
            </summary>
            <param name="mod"><see cref="T:Game.Modding.IMod"/> instance.</param>
        </member>
        <member name="M:Platter.ModSettings.SetDefaults">
            <summary>
            Restores mod settings to default.
            </summary>
        </member>
        <member name="M:Platter.ModSettings.IsNotInGame">
            <summary>
            Determines whether we're currently in-game (in a city) or not.
            </summary>
            <returns><c>false</c> if we're currently in-game, <c>true</c> otherwise (such as in the main menu or editor).</returns>
        </member>
        <member name="T:Platter.Patches.Patcher">
            <summary>
            A basic Harmony patching class.
            </summary>
        </member>
        <member name="M:Platter.Patches.Patcher.#ctor(System.String,Colossal.Logging.ILog)">
            <summary>
            Initializes a new instance of the <see cref="T:Platter.Patches.Patcher"/> class.
            Doing so applies all annotated patches.
            </summary>
            <param name="harmonyID">Harmony ID to use.</param>
            <param name="log">Log to use for performing patching.</param>
        </member>
        <member name="P:Platter.Patches.Patcher.Instance">
            <summary>
            Gets the active instance.
            </summary>
        </member>
        <member name="P:Platter.Patches.Patcher.PatchesApplied">
            <summary>
            Gets a value indicating whether patches were successfully applied.
            </summary>
        </member>
        <member name="P:Platter.Patches.Patcher.Log">
            <summary>
            Gets the logger to use when patching.
            </summary>
        </member>
        <member name="M:Platter.Patches.Patcher.UnPatchAll">
            <summary>
            Reverts all applied patches.
            </summary>
        </member>
        <member name="M:Platter.Patches.Patcher.PatchAnnotations">
            <summary>
            Constructor.
            Applies Harmony patches.
            </summary>
        </member>
        <member name="T:Platter.Systems.PrefabManager">
            <summary>
            This class provides the utility methods to install the mod.
            </summary>
        </member>
        <member name="F:Platter.Systems.PrefabManager.COUIBaseLocation">
            <summary>
                Base URI for all of our icons.
            </summary>
        </member>
        <member name="F:Platter.Systems.PrefabManager.installed">
            <summary>
                Guard boolean used to check if the Prefix already executed, so that we can prevent executing it multiple times.
            </summary>
        </member>
        <member name="F:Platter.Systems.PrefabManager.postInstalled">
            <summary>
                Guard boolean used to check if the Event Handler already executed, so that we can prevent executing it multiple times.
            </summary>
        </member>
        <member name="F:Platter.Systems.PrefabManager.world">
            <summary>
                <see cref="F:Platter.Systems.PrefabManager.world"/> instance used by our patch and by the loading event handler.
            </summary>
        </member>
        <member name="F:Platter.Systems.PrefabManager.prefabSystem">
            <summary>
                <see cref="F:Platter.Systems.PrefabManager.prefabSystem"/> instance used by our patch and by the loading event handler. 
            </summary>
        </member>
        <member name="M:Platter.Systems.PrefabManager.Install">
            <summary>
                <para>
                    Installing the mode means to add our cloned <see cref="T:Game.Prefabs.PrefabBase"/> to the global collection in
                    <see cref="F:Platter.Systems.PrefabManager.prefabSystem"/>.
                </para>
                <para>
                    To avoid getting the wrong <see cref="F:Platter.Systems.PrefabManager.world"/> instance we rely on Harmony's <see cref="T:HarmonyLib.Traverse"/> to extract the
                    <b>m_World</b> field from the injected <see cref="T:Game.SceneFlow.GameManager"/> instance.
                </para>
                <para>
                    After that, we leverage <see cref="M:Unity.Entities.World.GetOrCreateSystemManaged``1"/> to get our target <see cref="F:Platter.Systems.PrefabManager.prefabSystem"/>.
                    From there, to get <see cref="F:Platter.Systems.PrefabManager.prefabSystem"/>'s internal <see cref="T:Game.Prefabs.PrefabBase"/> list we use <see cref="T:HarmonyLib.Traverse"/>
                    again and we extract the <b>m_Prefabs</b> field.
                </para>
                <para>
                    We now have what it takes to extract our <see cref="T:Game.Prefabs.PrefabBase"/> object, and as reference we extract the one called
                    <b>Landfill</b>.
                    During this stage we only care for <see cref="T:Game.Prefabs.ComponentBase"/> and not <see cref="T:Unity.Entities.IComponentData"/>.
                </para>
                <para>
                    The only <see cref="T:Game.Prefabs.ComponentBase"/> we need to deal with is the attached <see cref="T:Game.Prefabs.UIObject"/>, which contains the
                    <see cref="F:Game.Prefabs.UIObject.m_Icon"/> property. This property is a relative URI pointing to a SVG file in your
                    <b>Cities2_Data\StreamingAssets\~UI~\GameUI\Media\Game\Icons</b> directory.
                </para>
                <para>
                    The <b>Cities2_Data\StreamingAssets\~UI~\GameUI\</b> MUST be omitted from the URI, resulting in a definition similar to:
                    <code>
                        myUIObject.m_Icon = "Media\Game\Icons\myIcon.svg
                    </code>
                </para>
                <para>
                    Once the <see cref="T:Game.Prefabs.UIObject"/> is properly set with an updated <see cref="F:Game.Prefabs.UIObject.m_Icon"/> and <see cref="!:UIObject.name"/>
                </para>
            </summary>
        </member>
        <member name="M:Platter.Systems.PrefabManager.GameManager_onGameLoadingComplete(Colossal.Serialization.Entities.Purpose,Game.GameMode)">
            <summary>
                <para>
                    This event handler performs the second phase of our custom modes patching.
                </para>
                <para>
                    While in the first phase we create the <see cref="T:Game.Prefabs.PrefabBase"/> without any <see cref="T:Unity.Entities.IComponentData"/>, in this one
                    we add the <see cref="T:Unity.Entities.IComponentData"/> that we need to define the behavior of our custom upgrade modes.
                </para>
                <para>
                    This behavior is defined by the <see cref="T:Game.Prefabs.PlaceableNetData"/> <see cref="T:Unity.Entities.IComponentData"/>, which allows us to specify
                    a collection of <see cref="F:Game.Prefabs.PlaceableNetData.m_SetUpgradeFlags"/> and <see cref="F:Game.Prefabs.PlaceableNetData.m_UnsetUpgradeFlags"/>.
                </para>
                <para>
                    These two collection contains all the needed <see cref="T:Game.Prefabs.CompositionFlags"/> that game will use to compose the final road.
                </para>
                <para>
                    <list type="bullet">
                        <ul>
                            <see cref="F:Game.Prefabs.PlaceableNetData.m_SetUpgradeFlags"/> contains the flags that must be added to the target road piece
                        </ul>
                        <ul>
                            <see cref="F:Game.Prefabs.PlaceableNetData.m_UnsetUpgradeFlags"/> contains the flags that must be removed from the target road piece
                        </ul>
                    </list>
                </para>
                <para>
                    The goal of this method is then to simply iterate over our cloned <see cref="T:Game.Prefabs.PrefabBase"/> Prefabs and add to each one of them
                    the appropriate <see cref="T:Game.Prefabs.PlaceableNetData"/>, based on the data set in our <see cref="!:Data.ExtendedRoadUpgrades.Modes"/> collection.
                </para>
            </summary>
            <param name="purpose"></param>
            <param name="mode"></param>
        </member>
    </members>
</doc>
